<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh" /><updated>2022-08-13T17:08:10+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">My Blogs</title><subtitle>My Blogs
</subtitle><author><name>duan-dky</name><email>courage159357@gmail.com</email></author><entry><title type="html">clash tun模式配置</title><link href="http://localhost:4000/2022/08/11/clash-tun-mode.html" rel="alternate" type="text/html" title="clash tun模式配置" /><published>2022-08-11T00:00:00+08:00</published><updated>2022-08-11T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/11/clash-tun-mode</id><content type="html" xml:base="http://localhost:4000/2022/08/11/clash-tun-mode.html"><![CDATA[<h1 id="dns">1. 劫持系统dns</h1>
<h2 id="dnsmasqdnsmasq">安装dnsmasq并启动dnsmasq</h2>
<pre><code>sudo dnf install dnsmasq
sudo systemctl start dnsmasq
</code></pre>
<h2 id="resolvconfresolvconfdnsip">删除系统自己的resolv.conf,并新建resolv.conf指定dns服务器ip</h2>
<p><em>注：systemd-resolved的dns服务器ip为127.0.0.53，dnsmasq为127.0.0.1</em></p>
<pre><code>sudo rm /etc/resolv.conf
sudo vim /etc/resolv.conf
</code></pre><pre><code>nameserver 127.0.0.1
options edns0 trust-ad
search .
</code></pre>
<p><strong>注意：需要关闭networkmanager的dns服务器防止dns服务器ip被替换</strong></p>
<pre><code>sudo vim /etc/NetworkManager/NetworkManager.conf
</code></pre><pre><code>[main]
dns = none
</code></pre>
<p><em>重启networkmanager</em></p>
<pre><code>sudo systemctl restart NetworkManager
</code></pre>
<p><em>编辑dnsmasq配置文件</em></p>
<pre><code>sudo vim /etc/dnsmasq.d/clash.conf
</code></pre><pre><code>no-hosts
no-resolv
server=127.0.0.1#1053 //将dns请求全部转发到clash
</code></pre>
<p><em>重新启动dnsmasq</em></p>
<pre><code>sudo systemctl restart dnsmasq
</code></pre>
<p><em>clash的dns服务器配置</em></p>
<p><em>config.yaml</em></p>
<pre><code>dns:
  enable: true
  ipv6: true
  listen: :1053
  enhanced-mode: fake-ip      # redir-host or fake-ip
  fake-ip-range: 198.18.0.1/16    # Fake IP addresses pool CIDR
  use-hosts: true                 # lookup hosts and return IP record
  nameserver:
    - 223.5.5.5         # 阿里 19ms
    - 119.29.29.29      # DNSpod DNS 17ms
  # 提供 fallback 时，如果GEOIP非 CN 中国时使用 fallback 解析
  fallback:
    - tls://8.8.8.8:53         # Google DNS over TLS 50ms
    - tls://8.8.4.4:53         # cloudflare DNS over TLS 50ms
    - https://1.1.1.1/dns-query # cloudflare DNS over HTTPS
    - https://dns.google/dns-query # Google DNS over HTTPS

  # 强制DNS解析使用`fallback`配置
  fallback-filter:
    # true: CN使用nameserver解析，非CN使用fallback
    geoip: true
    # geoip设置为false时有效： 不匹配`ipcidr`地址时会使用`nameserver`结果，匹配`ipcidr`地址时使用`fallback`结果。
    ipcidr:
      - 240.0.0.0/4

</code></pre>
<p><em>验证dns是否被劫持成功</em></p>
<pre><code>nslookup www.google.com
</code></pre>
<p><em>出现应答结果即为劫持成功</em></p>
<h1 id="clash-tun">2.clash tun网卡配置</h1>
<p><em>注：clash需要root权限创建网卡</em></p>
<pre><code>tun:
  enable: true
  stack: system
  auto-route: true
  auto-detect-interface: true
</code></pre>
<p>最后重启clash</p>
<pre><code>sudo systemctl restart clash
</code></pre>
<p>查看clash运行状态</p>
<pre><code>sudo systemctl status clash
</code></pre>]]></content><author><name>duan-dky</name><email>courage159357@gmail.com</email></author><category term="web" /><summary type="html"><![CDATA[1. 劫持系统dns 安装dnsmasq并启动dnsmasq sudo dnf install dnsmasq sudo systemctl start dnsmasq 删除系统自己的resolv.conf,并新建resolv.conf指定dns服务器ip 注：systemd-resolved的dns服务器ip为127.0.0.53，dnsmasq为127.0.0.1 sudo rm /etc/resolv.conf sudo vim /etc/resolv.conf nameserver 127.0.0.1 options edns0 trust-ad search . 注意：需要关闭networkmanager的dns服务器防止dns服务器ip被替换 sudo vim /etc/NetworkManager/NetworkManager.conf [main] dns = none 重启networkmanager sudo systemctl restart NetworkManager 编辑dnsmasq配置文件 sudo vim /etc/dnsmasq.d/clash.conf no-hosts no-resolv server=127.0.0.1#1053 //将dns请求全部转发到clash 重新启动dnsmasq sudo systemctl restart dnsmasq clash的dns服务器配置 config.yaml dns: enable: true ipv6: true listen: :1053 enhanced-mode: fake-ip # redir-host or fake-ip fake-ip-range: 198.18.0.1/16 # Fake IP addresses pool CIDR use-hosts: true # lookup hosts and return IP record nameserver: - 223.5.5.5 # 阿里 19ms - 119.29.29.29 # DNSpod DNS 17ms # 提供 fallback 时，如果GEOIP非 CN 中国时使用 fallback 解析 fallback: - tls://8.8.8.8:53 # Google DNS over TLS 50ms - tls://8.8.4.4:53 # cloudflare DNS over TLS 50ms - https://1.1.1.1/dns-query # cloudflare DNS over HTTPS - https://dns.google/dns-query # Google DNS over HTTPS # 强制DNS解析使用`fallback`配置 fallback-filter: # true: CN使用nameserver解析，非CN使用fallback geoip: true # geoip设置为false时有效： 不匹配`ipcidr`地址时会使用`nameserver`结果，匹配`ipcidr`地址时使用`fallback`结果。 ipcidr: - 240.0.0.0/4 验证dns是否被劫持成功 nslookup www.google.com 出现应答结果即为劫持成功 2.clash tun网卡配置 注：clash需要root权限创建网卡 tun: enable: true stack: system auto-route: true auto-detect-interface: true 最后重启clash sudo systemctl restart clash 查看clash运行状态 sudo systemctl status clash]]></summary></entry><entry><title type="html">nginx配置</title><link href="http://localhost:4000/2022/08/10/nginx-config.html" rel="alternate" type="text/html" title="nginx配置" /><published>2022-08-10T00:00:00+08:00</published><updated>2022-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/10/nginx-config</id><content type="html" xml:base="http://localhost:4000/2022/08/10/nginx-config.html"><![CDATA[<p><em>测试系统：Debian11</em></p>
<h1 id="section">1.安装升级系统</h1>
<pre><code>sudo apt update
</code></pre>
<h1 id="nginx">2.安装nginx</h1>
<pre><code>sudo apt install nginx
</code></pre>
<h1 id="section-1">3.申请域名</h1>
<p><em>github学生包或者freenom免费域名，添加域名解析，使用nslookup命令查看是否解析成功，注意先不要使用cdn</em></p>
<h1 id="section-2">4.申请证书</h1>
<p><em>zerossl或者letsencrypt即可</em></p>
<h2 id="letsencrypt">letsencrypt申请方法：</h2>
<pre><code>sudo apt install python3-certbot-nginx
</code></pre>
<p>安装完成后：</p>
<pre><code>sudo certbot –nginx
</code></pre>
<h1 id="nginx-1">5.编辑nginx配置文件</h1>
<p>编辑/etc/nginx/sites-enabled/default文件</p>
<pre><code>server {

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /var/www/html;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html index.php;
    server_name yourdomain;
        
        location / {
                try_files $uri $uri/ =404;
        }
	# pass PHP scripts to FastCGI server
	#
	location ~ \.php$ {
		include snippets/fastcgi-php.conf;
	
		# With php-fpm (or other unix sockets):
		fastcgi_pass unix:/run/php/php7.4-fpm.sock;
		# With php-cgi (or other tcp sockets):
		# fastcgi_pass 127.0.0.1:9000;
	}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}

    listen [::]:10005 ssl ipv6only=on; # managed by Certbot
    listen 10005 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/yourdomain/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/yourdomain/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot

}
server {
    if ($host = yourdomain ) { //http强制跳转至https
        return 301 https://$host$request_uri;
    } # managed by Certbot


	listen 80 ;
	listen [::]:80 ;
    server_name yourdomain;
    return 404; # managed by Certbot


}
</code></pre>
<p>6.启用nginx服务</p>
<pre><code>sudo systemctl enable –now nginx
</code></pre>
<p>7.浏览器查看网页</p>]]></content><author><name>duan-dky</name><email>courage159357@gmail.com</email></author><category term="web" /><summary type="html"><![CDATA[测试系统：Debian11 1.安装升级系统 sudo apt update 2.安装nginx sudo apt install nginx 3.申请域名 github学生包或者freenom免费域名，添加域名解析，使用nslookup命令查看是否解析成功，注意先不要使用cdn 4.申请证书 zerossl或者letsencrypt即可 letsencrypt申请方法： sudo apt install python3-certbot-nginx 安装完成后： sudo certbot –nginx 5.编辑nginx配置文件 编辑/etc/nginx/sites-enabled/default文件 server { # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don't use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html index.php; server_name yourdomain; location / { try_files $uri $uri/ =404; } # pass PHP scripts to FastCGI server # location ~ \.php$ { include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/run/php/php7.4-fpm.sock; # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; } # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht { # deny all; #} listen [::]:10005 ssl ipv6only=on; # managed by Certbot listen 10005 ssl; # managed by Certbot ssl_certificate /etc/letsencrypt/live/yourdomain/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/yourdomain/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } server { if ($host = yourdomain ) { //http强制跳转至https return 301 https://$host$request_uri; } # managed by Certbot listen 80 ; listen [::]:80 ; server_name yourdomain; return 404; # managed by Certbot } 6.启用nginx服务 sudo systemctl enable –now nginx 7.浏览器查看网页]]></summary></entry><entry><title type="html">trojan-go配置</title><link href="http://localhost:4000/2022/08/10/trojan-config.html" rel="alternate" type="text/html" title="trojan-go配置" /><published>2022-08-10T00:00:00+08:00</published><updated>2022-08-10T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/10/trojan-config</id><content type="html" xml:base="http://localhost:4000/2022/08/10/trojan-config.html"><![CDATA[<p>1.github下载trojan-go二进制文件</p>
<pre><code>wget https://github.com/p4gefau1t/trojan-go/releases/download/v0.10.6/trojan-go-linux-amd64.zip
</code></pre>
<p>2.解压trojan-go并放至/usr/bin,赋予其执行权限</p>
<pre><code>unzip trojan-go-linux-amd64.zip
cp trojan-go /usr/bin
chmod +x trojan-go
</code></pre>
<p>3.将剩余文件放至/etc/trojan-go</p>
<pre><code>mkdir /etc/trojan-go
cp -r * /etc/trojan-go
</code></pre>
<p>4.申请trojan-go的证书</p>
<pre><code>sudo certbot certonly –agree-tos –standalone –no-eff-email -m youremail -d yourdomain
</code></pre>
<p>将证书移至/etc/trojan-go中</p>
<pre><code>sudo cp -r /etc/letsencrypt/archive/yourdomain /etc/trojan-go
</code></pre>
<p>5.编辑config.json<br />
<em>生成随机uuid</em></p>
<pre><code>cat /proc/sys/kernel/random/uuid
</code></pre>
<p><em>config.json</em></p>
<pre><code>{
    &quot;run_type&quot;: &quot;server&quot;,
    &quot;local_addr&quot;: &quot;0.0.0.0&quot;,
    &quot;local_port&quot;: 10010, //与nginx共存时不可填写443端口
    &quot;remote_addr&quot;: &quot;127.0.0.1&quot;,
    &quot;remote_port&quot;: 80, //默认返回网页
    &quot;password&quot;: [
        &quot;yourpassword&quot; //填写自己密码
    ],
    &quot;ssl&quot;: {
        &quot;cert&quot;: &quot;/etc/trojan-go/yourdomain/fullchain1.pem&quot;, //网站的证书
        &quot;key&quot;: &quot;/etc/trojan-go/yourdomain/privkey1.pem&quot;,
	&quot;fallback&quot;: 10005, //回程默认网页
        &quot;sni&quot;: &quot;yourdomain&quot;
    },
    &quot;websocket&quot;: { //ws模式伪装path
	&quot;enabled&quot;: true,
	&quot;path&quot;: &quot;/yourpath&quot;, //建议填写随机值
	&quot;host&quot;: &quot;yourdomain&quot;
    }
}
</code></pre>
<p>6.设置端口转发
由于trojan与nginx都占用443端口，因此需设置端口转发</p>
<p><em>nginx.conf</em></p>
<pre><code>stream { 
# 这里就是 SNI 识别，将域名映射成一个配置名，请修改自己的一级域名 
  map $ssl_preread_server_name $backend_name { 
    yourdomain web;
    yourdomain trojan;
    default web; 
  } 
# web，配置转发详情 
  upstream web { 
    server 127.0.0.1:10005;
  }
  upstream trojan {
    server 127.0.0.1:10010;
  }
# 监听 443 并开启 ssl_preread
  server { 
    listen 443 reuseport; 
    listen [::]:443 reuseport;
    proxy_pass $backend_name; 
    ssl_preread on; 
  }
}
</code></pre>
<p>7.新建trojan用户
<em>用于安全原因，trojan-go需要以trojan用户的身份运行</em></p>
<pre><code>sudo useradd -s /sbin/nologin trojan
</code></pre>
<p><em>设置文件夹权限</em></p>
<pre><code>sudo chown -R /etc/trojan-go
</code></pre>
<p>7.新建systemd服务</p>
<pre><code>sudo vim /usr/lib/systemd/system/trojan-go.service
</code></pre>
<p><em>trojan-go.service</em></p>
<pre><code>[Unit]
Description=Trojan-Go - An unidentifiable mechanism that helps you bypass GFW
Documentation=https://p4gefau1t.github.io/trojan-go/
After=network.target nss-lookup.target

[Service]
User=trojan
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE
NoNewPrivileges=true
ExecStart=/usr/bin/trojan-go -config /etc/trojan-go/config.json
Restart=on-failure
RestartSec=10s
LimitNOFILE=infinity

[Install]
WantedBy=multi-user.target
sudo systemctl daemon-reload //重载systemd服务
</code></pre>
<p>8.重启nginx并设置trojan-go开机启动</p>
<pre><code>sudo systemctl enable –now trojan-go
sudo systemctl restart nginx
</code></pre>
<p>9.客户端设置（自选客户端）<br />
<em>设置clash</em></p>
<pre><code>- name: 'trojan'
      type: trojan
      server: yourdomain
      port: '443'
      password: &quot;yourwassword&quot;
      sni: yoursni
      udp: true
      ws-opts:
        path: /yourpath
        headers:
          Host: yourdomain
</code></pre>]]></content><author><name>duan-dky</name><email>courage159357@gmail.com</email></author><category term="web" /><summary type="html"><![CDATA[1.github下载trojan-go二进制文件 wget https://github.com/p4gefau1t/trojan-go/releases/download/v0.10.6/trojan-go-linux-amd64.zip 2.解压trojan-go并放至/usr/bin,赋予其执行权限 unzip trojan-go-linux-amd64.zip cp trojan-go /usr/bin chmod +x trojan-go 3.将剩余文件放至/etc/trojan-go mkdir /etc/trojan-go cp -r * /etc/trojan-go 4.申请trojan-go的证书 sudo certbot certonly –agree-tos –standalone –no-eff-email -m youremail -d yourdomain 将证书移至/etc/trojan-go中 sudo cp -r /etc/letsencrypt/archive/yourdomain /etc/trojan-go 5.编辑config.json 生成随机uuid cat /proc/sys/kernel/random/uuid config.json { &quot;run_type&quot;: &quot;server&quot;, &quot;local_addr&quot;: &quot;0.0.0.0&quot;, &quot;local_port&quot;: 10010, //与nginx共存时不可填写443端口 &quot;remote_addr&quot;: &quot;127.0.0.1&quot;, &quot;remote_port&quot;: 80, //默认返回网页 &quot;password&quot;: [ &quot;yourpassword&quot; //填写自己密码 ], &quot;ssl&quot;: { &quot;cert&quot;: &quot;/etc/trojan-go/yourdomain/fullchain1.pem&quot;, //网站的证书 &quot;key&quot;: &quot;/etc/trojan-go/yourdomain/privkey1.pem&quot;, &quot;fallback&quot;: 10005, //回程默认网页 &quot;sni&quot;: &quot;yourdomain&quot; }, &quot;websocket&quot;: { //ws模式伪装path &quot;enabled&quot;: true, &quot;path&quot;: &quot;/yourpath&quot;, //建议填写随机值 &quot;host&quot;: &quot;yourdomain&quot; } } 6.设置端口转发 由于trojan与nginx都占用443端口，因此需设置端口转发 nginx.conf stream { # 这里就是 SNI 识别，将域名映射成一个配置名，请修改自己的一级域名 map $ssl_preread_server_name $backend_name { yourdomain web; yourdomain trojan; default web; } # web，配置转发详情 upstream web { server 127.0.0.1:10005; } upstream trojan { server 127.0.0.1:10010; } # 监听 443 并开启 ssl_preread server { listen 443 reuseport; listen [::]:443 reuseport; proxy_pass $backend_name; ssl_preread on; } } 7.新建trojan用户 用于安全原因，trojan-go需要以trojan用户的身份运行 sudo useradd -s /sbin/nologin trojan 设置文件夹权限 sudo chown -R /etc/trojan-go 7.新建systemd服务 sudo vim /usr/lib/systemd/system/trojan-go.service trojan-go.service [Unit] Description=Trojan-Go - An unidentifiable mechanism that helps you bypass GFW Documentation=https://p4gefau1t.github.io/trojan-go/ After=network.target nss-lookup.target [Service] User=trojan CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE NoNewPrivileges=true ExecStart=/usr/bin/trojan-go -config /etc/trojan-go/config.json Restart=on-failure RestartSec=10s LimitNOFILE=infinity [Install] WantedBy=multi-user.target sudo systemctl daemon-reload //重载systemd服务 8.重启nginx并设置trojan-go开机启动 sudo systemctl enable –now trojan-go sudo systemctl restart nginx 9.客户端设置（自选客户端） 设置clash - name: 'trojan' type: trojan server: yourdomain port: '443' password: &quot;yourwassword&quot; sni: yoursni udp: true ws-opts: path: /yourpath headers: Host: yourdomain]]></summary></entry><entry><title type="html">git配置</title><link href="http://localhost:4000/2022/08/05/git-config.html" rel="alternate" type="text/html" title="git配置" /><published>2022-08-05T00:00:00+08:00</published><updated>2022-08-05T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/05/git-config</id><content type="html" xml:base="http://localhost:4000/2022/08/05/git-config.html"><![CDATA[<h1 id="git">安装git</h1>
<h2 id="linux">Linux</h2>
<pre><code>sudo apt install git //Debian
</code></pre><pre><code>sudo dnf install git //Fedora
</code></pre>
<h2 id="windows">Windows</h2>
<h3 id="section">直接安装</h3>
<p><a href="https://github.com/git-for-windows/git/releases/download/v2.37.1.windows.1/Git-2.37.1-64-bit.exe">下载链接</a></p>
<h3 id="winget">winget安装</h3>
<pre><code>winget install --id Git.Git -e --source winget
</code></pre>
<h1 id="git-1">git初步配置</h1>
<pre><code>git config --global user.name &quot;username&quot; //用户名
</code></pre><pre><code>git config --list //已有配置信息
</code></pre><pre><code>git config --global user.email youremail //邮箱
</code></pre><pre><code>git config --global core.editor nvim //默认文本编辑器
</code></pre><pre><code>git config --global merge.tool vimdiff //差异分析工具
</code></pre>
<h1 id="git-2">git使用</h1>
<p><strong>概念:</strong><br />
工作区：就是你在电脑里能看到的目录。<br />
暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。<br />
版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</p>
<h2 id="section-1">基本操作</h2>
<pre><code>git init //初始化仓库
</code></pre>
<p><strong>注：第一次初始提交后才有master分支</strong></p>
<pre><code>git reset HEAD //版本回退，重写暂存区的目录树，被 master 分支指向的目录树所替换
</code></pre><pre><code>git rm --cached &lt;file&gt;  //直接从暂存区删除文件，工作区则不做出改变
</code></pre><pre><code>git checkout .  //清除工作区中未添加到暂存区中的改动
</code></pre><pre><code>git mv    //移动或重命名工作区文件
</code></pre><pre><code>git checkout HEAD . //用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件
</code></pre><pre><code>git add file //将文件加入版本控制
</code></pre><pre><code>git commit -m 'first commit' //提交说明
</code></pre><pre><code>git status //查看仓库状态
</code></pre><pre><code>git clone &lt;repo&gt; &lt;directory&gt; //拷贝项目到指定目录
</code></pre><pre><code>git log //查看历史提交记录
</code></pre><pre><code>git blame &lt;path&gt; //查看文件修改记录（列表形式）
</code></pre><pre><code>git pull //下载源代码合并
</code></pre><pre><code>git push //上传源代码合并
</code></pre><pre><code>git fetch //从远程获取代码库
</code></pre>
<h2 id="git-diff">git diff命令</h2>
<p><em>不加参数即默认比较工作区与暂存区</em></p>
<pre><code>git diff
</code></pre>
<p><em>比较暂存区与最新本地版本库</em></p>
<pre><code>git diff --cached  [&lt;path&gt;...] 
</code></pre>
<p><em>比较工作区与最新本地版本库</em></p>
<p><em>注：如果HEAD指向的是master分支，那么HEAD还可以换成master</em></p>
<pre><code>git diff HEAD [&lt;path&gt;...]
</code></pre>
<p><em>比较工作区与指定commit-id的差异</em></p>
<pre><code>git diff commit-id  [&lt;path&gt;...]
</code></pre>
<p><em>比较暂存区与指定commit-id的差异</em></p>
<pre><code>git diff --cached [&lt;commit-id&gt;] [&lt;path&gt;...] 
</code></pre>
<p><em>比较两个commit-id之间的差异</em></p>
<pre><code>git diff [&lt;commit-id&gt;] [&lt;commit-id&gt;]
</code></pre>
<h3 id="git-diff-1">使用git diff打补丁</h3>
<h4 id="section-2">做补丁</h4>
<pre><code>git diff &gt; patch //patch命名随意
git diff --cached &gt; patch //是将我们暂存区与版本库的差异做成补丁
git diff --HEAD &gt; patch //是将工作区与版本库的差异做成补丁
git diff Testfile &gt; patch//将单个文件做成一个单独的补丁
</code></pre>
<h4 id="section-3">打补丁</h4>
<pre><code>git apply patch //打补丁
git apply --check patch //无输出表示可以顺利接受补丁
git apply --reject patch //若有冲突则生成.rej文件，可手动打补丁
</code></pre>
<h2 id="git-branch">git branch命令</h2>
<p><em>列出分支</em></p>
<pre><code>git branch
</code></pre>
<p><em>创建分支</em></p>
<pre><code>git branch (branchname)
</code></pre>
<p><em>切换分支</em></p>
<pre><code>git checkout (branchname)
</code></pre>
<p><strong>注：使用分支将工作切分开来，并能够来回切换。</strong></p>
<p><img src="https://duan-dky.me/assets/images/posts/git-config/git-checkout.png" alt="git-checkout" /></p>
<p>如图，切换到test分支后创建README.md,提交更改，然后切换回master分支后发现README.md消失，再切换回test分支后README.md文件出现。</p>
<p><em>合并分支</em></p>
<pre><code>git merge 
</code></pre>
<p><strong>注：多次合并到统一分支， 也可在合并之后直接删除被并入的分支。</strong></p>]]></content><author><name>duan-dky</name><email>courage159357@gmail.com</email></author><category term="git" /><summary type="html"><![CDATA[安装git Linux sudo apt install git //Debian sudo dnf install git //Fedora Windows 直接安装 下载链接 winget安装 winget install --id Git.Git -e --source winget git初步配置 git config --global user.name &quot;username&quot; //用户名 git config --list //已有配置信息 git config --global user.email youremail //邮箱 git config --global core.editor nvim //默认文本编辑器 git config --global merge.tool vimdiff //差异分析工具 git使用 概念: 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 基本操作 git init //初始化仓库 注：第一次初始提交后才有master分支 git reset HEAD //版本回退，重写暂存区的目录树，被 master 分支指向的目录树所替换 git rm --cached &lt;file&gt; //直接从暂存区删除文件，工作区则不做出改变 git checkout . //清除工作区中未添加到暂存区中的改动 git mv //移动或重命名工作区文件 git checkout HEAD . //用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件 git add file //将文件加入版本控制 git commit -m 'first commit' //提交说明 git status //查看仓库状态 git clone &lt;repo&gt; &lt;directory&gt; //拷贝项目到指定目录 git log //查看历史提交记录 git blame &lt;path&gt; //查看文件修改记录（列表形式） git pull //下载源代码合并 git push //上传源代码合并 git fetch //从远程获取代码库 git diff命令 不加参数即默认比较工作区与暂存区 git diff 比较暂存区与最新本地版本库 git diff --cached [&lt;path&gt;...] 比较工作区与最新本地版本库 注：如果HEAD指向的是master分支，那么HEAD还可以换成master git diff HEAD [&lt;path&gt;...] 比较工作区与指定commit-id的差异 git diff commit-id [&lt;path&gt;...] 比较暂存区与指定commit-id的差异 git diff --cached [&lt;commit-id&gt;] [&lt;path&gt;...] 比较两个commit-id之间的差异 git diff [&lt;commit-id&gt;] [&lt;commit-id&gt;] 使用git diff打补丁 做补丁 git diff &gt; patch //patch命名随意 git diff --cached &gt; patch //是将我们暂存区与版本库的差异做成补丁 git diff --HEAD &gt; patch //是将工作区与版本库的差异做成补丁 git diff Testfile &gt; patch//将单个文件做成一个单独的补丁 打补丁 git apply patch //打补丁 git apply --check patch //无输出表示可以顺利接受补丁 git apply --reject patch //若有冲突则生成.rej文件，可手动打补丁 git branch命令 列出分支 git branch 创建分支 git branch (branchname) 切换分支 git checkout (branchname) 注：使用分支将工作切分开来，并能够来回切换。 如图，切换到test分支后创建README.md,提交更改，然后切换回master分支后发现README.md消失，再切换回test分支后README.md文件出现。 合并分支 git merge 注：多次合并到统一分支， 也可在合并之后直接删除被并入的分支。]]></summary></entry><entry><title type="html">fedora基本配置</title><link href="http://localhost:4000/2022/08/03/fedora-config.html" rel="alternate" type="text/html" title="fedora基本配置" /><published>2022-08-03T00:00:00+08:00</published><updated>2022-08-03T00:00:00+08:00</updated><id>http://localhost:4000/2022/08/03/fedora-config</id><content type="html" xml:base="http://localhost:4000/2022/08/03/fedora-config.html"><![CDATA[<h1 id="section">1.软件包管理工具</h1>
<h2 id="dnf">dnf命令</h2>
<pre><code>sudo dnf makecache //建立软件包缓存
</code></pre><pre><code>sudo dnf upgrade //进行软件包更新
</code></pre><pre><code>sudo dnf upgrade package_name //更新单个软件包
</code></pre><pre><code>sudo dnf install https://mirrors.ustc.edu.cn/rpmfusion/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.ustc.edu.cn/rpmfusion/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm //启用rpmfusion软件仓库
</code></pre><pre><code>dnf search package_name //搜索软件包
</code></pre><pre><code>dnf list kernel-* //查找软件包，使用通配符
</code></pre><pre><code>dnf list all //列出所有软件包
</code></pre><pre><code>dnf list installed package_name //列出已安装软件包
</code></pre><pre><code>dnf group list //列出所有包组
</code></pre><pre><code>dnf repolist //列出已启用的软件仓库
</code></pre><pre><code>dnf repository-packages fedora list //列出来自单个软件仓库的软件包
</code></pre><pre><code>dnf info package_name //显示单个软件包的信息
</code></pre><pre><code>dnf repoquery package_name --info //列出具体软件包的所有信息
</code></pre><pre><code>dnf provides &quot;*bin/named&quot; //列出哪个软件包提供了该二进制文件
</code></pre><pre><code>dnf -v group list group_name //列出某个软件包组的详细信息
</code></pre><pre><code>sudo dnf install package_name //安装单个软件包
</code></pre><pre><code>sudo dnf install /usr/sbin/named //不知道包名的情况下使用
</code></pre><pre><code>sudo dnf groupinstall group_nane //安装软件包组
</code></pre><pre><code>sudo dnf remove package _name //卸载软件包
</code></pre><pre><code>sudo dnf group remove group_name //卸载软件包组
</code></pre><pre><code>dnf history list //列出所有事务
</code></pre>
<h1 id="section-1">2.驱动安装</h1>
<h2 id="section-2">显卡</h2>
<pre><code>lspci -k | grep -EA3 'VGA|3D|Display' //查看显卡型号
</code></pre>
<h3 id="amd-intel">AMD, Intel显卡免驱</h3>
<pre><code>lsmod|grep amdgpu //查看模块加载情况
</code></pre>
<h3 id="nvidia-">NVIDIA 显卡驱动安装</h3>
<h4 id="section-3">1.进行软件包更新</h4>
<pre><code>sudo dnf update  --refresh
</code></pre>
<h4 id="section-4">2. 安装驱动程序及其依赖</h4>
<pre><code>sudo dnf install gcc kernel-headers kernel-devel akmod-nvidia xorg-x11-drv-nvidia xorg-x11-drv-nvidia-libs xorg-x11-drv-nvidia-libs.i686
</code></pre>
<h4 id="section-5">3.等待驱动模块加载，过程需要5~10分钟</h4>
<pre><code>ps -e | grep akmods //执行命令无输出说明模块安装完成
</code></pre>
<h4 id="section-6">4.强制从更新的内核模块中读取配置</h4>
<pre><code>sudo akmods --force 
sudo dracut --force
</code></pre>
<h4 id="section-7">5.命令完成后重新启动系统</h4>
<pre><code>sudo reboot
</code></pre><pre><code>lsmod | grep nvidia //查看模块加载情况
</code></pre>
<h1 id="systemd">3. systemd服务</h1>
<pre><code>systemctl start service_name //启动服务
</code></pre><pre><code>systemctl restart service_name //重启服务
</code></pre><pre><code>systemctl enable service_name //服务自动启动
</code></pre><pre><code>systemctl disable service_name //服务取消自动启动
</code></pre><pre><code>systemctl mask service_name //屏蔽服务
</code></pre><pre><code>systemctl is-enabled service_name //查看服务是否自动启动
</code></pre><pre><code>systemctl edit httpd.service //编辑服务
</code></pre><pre><code>vim /etc/systemd/system/foo.service //新建服务
</code></pre><pre><code>//示例
[Unit]
Description=frpc //服务描述
After=network.target //在网络连接激活后启动

[Service]
Type=simple //服务类型
ExecStart=/usr/bin/frpc -c frp.ini //命令

[Install]
WantedBy=multi-user.target
</code></pre><pre><code>systemctl status service_name //查看服务运行状态
</code></pre><pre><code>journalctl -u service_name //查看服务运行日志
</code></pre><pre><code>journalctl --vacuum-size=1M //清理运行日志
</code></pre>
<h1 id="vim">4.vim命令</h1>
<h2 id="section-8">命令模式</h2>
<p>i 进入编辑模式<br />
x 删除当前光标所在处的字符<br />
: 切换到底线命令模式</p>
<h2 id="section-9">输入模式</h2>
<p><em>回车键换行</em><br />
<em>退格键删除光标前一个字符</em><br />
*删除键删除光标后一个字符 *
<em>方向键在文本中移动光标</em><br />
<em>HOME/END移动光标到行首/行尾</em>
<em>Page Up/Page Down上/下翻页</em><br />
<em>Insert切换光标为输入/替换模式，光标将变成竖线/下划线</em><br />
<em>ESC退出输入模式，切换到命令模式</em></p>
<p><em>输入“/”搜索字符串，回车后跳转到对应字符串位置</em></p>
<h1 id="kvm">5.KVM虚拟化</h1>
<pre><code>egrep '^flags.*(vmx|svm)' /proc/cpuinfo //查看CPU是否支持虚拟化，有输出说明CPU支持虚拟化
</code></pre><pre><code>sudo dnf install @virtualization //安装虚拟化包组
</code></pre><pre><code>sudo systemctl enable --now libvirtd //设置libvirtd自动启动并启动服务
</code></pre><pre><code>lsmod | grep kvm //查看KVM内核模块是否加载
</code></pre>
<h2 id="virsh-install">使用virsh-install配置</h2>
<pre><code>sudo virt-install --name Fedora \
--description 'Fedora' \
--ram 4096 \
--vcpus 4 \
--disk path=/var/lib/libvirt/images/linux.qcow2,size=20 \
--os-type linux \
--os-variant fedora36 \
--network bridge=virbr0 \
--graphics vnc,listen=127.0.0.1,port=5901 \
--cdrom Fedora-Workstation-Live-x86-64-36-1.1.iso \
--noautoconsole
</code></pre>
<h2 id="virt-manager">使用virt-manager配置</h2>
<h3 id="gui">根据gui界面管理</h3>
<h2 id="virsh">使用virsh配置</h2>
<pre><code>virsh create machine_name //创建虚拟机
</code></pre><pre><code>virsh list --all //列出所有虚拟机
</code></pre><pre><code>virsh dumpxml &lt;virtual machine (name | id | uuid) //导出配置文件
</code></pre><pre><code>virsh shutdown machine_name //虚拟机关机
</code></pre><pre><code>virsh destroy machine_name //虚拟机强制关机
</code></pre>
<h1 id="flathub">6.启用flathub软件仓库</h1>
<p><em>添加软件原</em></p>
<pre><code>flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
</code></pre>
<p><em>搜索软件包</em></p>
<pre><code>flatpak --user search package_name
</code></pre>
<p><em>安装软件包</em></p>
<pre><code>flatpak --user install package_name
</code></pre>
<p><em>删除软件包</em></p>
<pre><code>flatpak --user remove package_name
</code></pre>]]></content><author><name>duan-dky</name><email>courage159357@gmail.com</email></author><category term="linux" /><summary type="html"><![CDATA[1.软件包管理工具 dnf命令 sudo dnf makecache //建立软件包缓存 sudo dnf upgrade //进行软件包更新 sudo dnf upgrade package_name //更新单个软件包 sudo dnf install https://mirrors.ustc.edu.cn/rpmfusion/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm https://mirrors.ustc.edu.cn/rpmfusion/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm //启用rpmfusion软件仓库 dnf search package_name //搜索软件包 dnf list kernel-* //查找软件包，使用通配符 dnf list all //列出所有软件包 dnf list installed package_name //列出已安装软件包 dnf group list //列出所有包组 dnf repolist //列出已启用的软件仓库 dnf repository-packages fedora list //列出来自单个软件仓库的软件包 dnf info package_name //显示单个软件包的信息 dnf repoquery package_name --info //列出具体软件包的所有信息 dnf provides &quot;*bin/named&quot; //列出哪个软件包提供了该二进制文件 dnf -v group list group_name //列出某个软件包组的详细信息 sudo dnf install package_name //安装单个软件包 sudo dnf install /usr/sbin/named //不知道包名的情况下使用 sudo dnf groupinstall group_nane //安装软件包组 sudo dnf remove package _name //卸载软件包 sudo dnf group remove group_name //卸载软件包组 dnf history list //列出所有事务 2.驱动安装 显卡 lspci -k | grep -EA3 'VGA|3D|Display' //查看显卡型号 AMD, Intel显卡免驱 lsmod|grep amdgpu //查看模块加载情况 NVIDIA 显卡驱动安装 1.进行软件包更新 sudo dnf update --refresh 2. 安装驱动程序及其依赖 sudo dnf install gcc kernel-headers kernel-devel akmod-nvidia xorg-x11-drv-nvidia xorg-x11-drv-nvidia-libs xorg-x11-drv-nvidia-libs.i686 3.等待驱动模块加载，过程需要5~10分钟 ps -e | grep akmods //执行命令无输出说明模块安装完成 4.强制从更新的内核模块中读取配置 sudo akmods --force sudo dracut --force 5.命令完成后重新启动系统 sudo reboot lsmod | grep nvidia //查看模块加载情况 3. systemd服务 systemctl start service_name //启动服务 systemctl restart service_name //重启服务 systemctl enable service_name //服务自动启动 systemctl disable service_name //服务取消自动启动 systemctl mask service_name //屏蔽服务 systemctl is-enabled service_name //查看服务是否自动启动 systemctl edit httpd.service //编辑服务 vim /etc/systemd/system/foo.service //新建服务 //示例 [Unit] Description=frpc //服务描述 After=network.target //在网络连接激活后启动 [Service] Type=simple //服务类型 ExecStart=/usr/bin/frpc -c frp.ini //命令 [Install] WantedBy=multi-user.target systemctl status service_name //查看服务运行状态 journalctl -u service_name //查看服务运行日志 journalctl --vacuum-size=1M //清理运行日志 4.vim命令 命令模式 i 进入编辑模式 x 删除当前光标所在处的字符 : 切换到底线命令模式 输入模式 回车键换行 退格键删除光标前一个字符 *删除键删除光标后一个字符 * 方向键在文本中移动光标 HOME/END移动光标到行首/行尾 Page Up/Page Down上/下翻页 Insert切换光标为输入/替换模式，光标将变成竖线/下划线 ESC退出输入模式，切换到命令模式 输入“/”搜索字符串，回车后跳转到对应字符串位置 5.KVM虚拟化 egrep '^flags.*(vmx|svm)' /proc/cpuinfo //查看CPU是否支持虚拟化，有输出说明CPU支持虚拟化 sudo dnf install @virtualization //安装虚拟化包组 sudo systemctl enable --now libvirtd //设置libvirtd自动启动并启动服务 lsmod | grep kvm //查看KVM内核模块是否加载 使用virsh-install配置 sudo virt-install --name Fedora \ --description 'Fedora' \ --ram 4096 \ --vcpus 4 \ --disk path=/var/lib/libvirt/images/linux.qcow2,size=20 \ --os-type linux \ --os-variant fedora36 \ --network bridge=virbr0 \ --graphics vnc,listen=127.0.0.1,port=5901 \ --cdrom Fedora-Workstation-Live-x86-64-36-1.1.iso \ --noautoconsole 使用virt-manager配置 根据gui界面管理 使用virsh配置 virsh create machine_name //创建虚拟机 virsh list --all //列出所有虚拟机 virsh dumpxml &lt;virtual machine (name | id | uuid) //导出配置文件 virsh shutdown machine_name //虚拟机关机 virsh destroy machine_name //虚拟机强制关机 6.启用flathub软件仓库 添加软件原 flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo 搜索软件包 flatpak --user search package_name 安装软件包 flatpak --user install package_name 删除软件包 flatpak --user remove package_name]]></summary></entry><entry><title type="html">frp内网穿透</title><link href="http://localhost:4000/2022/07/31/frp-config.html" rel="alternate" type="text/html" title="frp内网穿透" /><published>2022-07-31T00:00:00+08:00</published><updated>2022-07-31T00:00:00+08:00</updated><id>http://localhost:4000/2022/07/31/frp-config</id><content type="html" xml:base="http://localhost:4000/2022/07/31/frp-config.html"><![CDATA[<h1 id="frp-server">1.frp server端配置</h1>
<pre><code>[common]
# frp监听的端口，默认是7000，可以改成其他的
bind_port = 14823
vhost_http_port = 12345
# 授权码，请改成更复杂的
token = 12345678

# frp管理后台端口，请按自己需求更改
dashboard_port = 7800 
# frp管理后台用户名和密码，请改成自己的
dashboard_user = admin
dashboard_pwd = admin
enable_prometheus = true
</code></pre>
<h1 id="frp-client">2.frp client端配置</h1>
<pre><code>[common]
server_addr = yourdomain
server_port = 14823 #server端bind_port
token = 12345678  #授权码
[ssh]   #ssh远程链接
type = tcp
local_ip = 127.0.0.1
local_port = 22 #本地ssh端口
remote_port = 6000 #远程ssh连接端口
[web1]
type = http #http服务
local_port = 80
custom_domains = yourdomain
</code></pre>
<h1 id="frpmariadb">3.frp配置mariadb</h1>
<pre><code>[mariadb]
type = tcp
local_ip = 127.0.0.1   #内网ip
local_port = 3306 # 内网mariadb端口
remote_port = 1006 # 公网mariadb端口
</code></pre>
<h1 id="frpnginx80443">4.frp与nginx共用80、443端口</h1>
<h2 id="http">http</h2>
<h3 id="nginx">nginx配置</h3>
<pre><code>location / {
        # First attempt to serve request as file, then
        # as directory, then fall back to displaying a 404.
        # try_files $uri $uri/ =404;
        proxy_pass http://127.0.0.1:8081; #填写frpc的vhost端口
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header REMOTE-HOST $remote_addr;
    }
</code></pre>
<h3 id="frp-server-1">frp server端配置</h3>
<pre><code>vhost_http_port = 8081
</code></pre>
<h3 id="frp-client-1">frp client配置</h3>
<pre><code>[web1]
type = http
local_port = 80
custom_domains = yourdomain
</code></pre>
<h2 id="https">https</h2>
<h3 id="frp">配置frp</h3>
<h4 id="frp-server-2">frp server</h4>
<pre><code>vhost_https_port = 8082
</code></pre>
<h4 id="frp-client-2">frp client</h4>
<pre><code>#plugin = https2http
#plugin_local_addr = 127.0.0.1:1313 #本地服务器端口

# HTTPS证书的路径
#plugin_crt_path = /etc/frp/domain/yourdomain/fullchain1.pem
#plugin_key_path = /etc/frp/domain/yourdomain/privkey1.pem
#plugin_host_header_rewrite = 127.0.0.1
#plugin_header_X-From-Where = frp
</code></pre>
<h3 id="nginx-1">或配置nginx</h3>
<pre><code>  map $ssl_preread_server_name $backend_name {
    default frp;
  }
  upstream frp {
    server 127.0.0.1:10013;
  }
server {
   listen 10013 ssl;
   server_name *.duan-dky.me;
   ssl_certificate /etc/letsencrypt/live/duan-dky.me/fullchain.pem;
   ssl_certificate_key /etc/letsencrypt/live/duan-dky.me/privkey.pem;
   location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                # try_files $uri $uri/ =404;
            proxy_pass http://127.0.0.1:8082;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $http_host;
            proxy_set_header X-NginX-Proxy true;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection &quot;upgrade&quot;;
            proxy_max_temp_file_size 0;
            proxy_redirect off;
        } 
}
</code></pre>
<h1 id="frpsystemd">5.frp注册成systemd服务</h1>
<p><em>frp server端</em></p>
<pre><code>[Unit]
Description=FRP Server Daemon

[Service]
Type=simple
ExecStartPre=-/usr/sbin/setcap cap_net_bind_service=+ep /usr/bin/frps
ExecStart=/usr/bin/frps -c /etc/frp/frps.ini
Restart=always
RestartSec=2s
User=nobody
PermissionsStartOnly=true
LimitNOFILE=infinity

[Install]
WantedBy=multi-user.target

</code></pre>
<p><em>frp client端</em></p>
<pre><code>[Unit]
Description=FRP Client Daemon
After=network.target
Wants=network.target

[Service]
Type=simple
ExecStart=/usr/bin/frpc -c /etc/frp/frpc.ini
Restart=always
RestartSec=20s
User=nobody
LimitNOFILE=infinity

[Install]
WantedBy=multi-user.target

</code></pre>]]></content><author><name>duan-dky</name><email>courage159357@gmail.com</email></author><category term="web" /><summary type="html"><![CDATA[1.frp server端配置 [common] # frp监听的端口，默认是7000，可以改成其他的 bind_port = 14823 vhost_http_port = 12345 # 授权码，请改成更复杂的 token = 12345678 # frp管理后台端口，请按自己需求更改 dashboard_port = 7800 # frp管理后台用户名和密码，请改成自己的 dashboard_user = admin dashboard_pwd = admin enable_prometheus = true 2.frp client端配置 [common] server_addr = yourdomain server_port = 14823 #server端bind_port token = 12345678 #授权码 [ssh] #ssh远程链接 type = tcp local_ip = 127.0.0.1 local_port = 22 #本地ssh端口 remote_port = 6000 #远程ssh连接端口 [web1] type = http #http服务 local_port = 80 custom_domains = yourdomain 3.frp配置mariadb [mariadb] type = tcp local_ip = 127.0.0.1 #内网ip local_port = 3306 # 内网mariadb端口 remote_port = 1006 # 公网mariadb端口 4.frp与nginx共用80、443端口 http nginx配置 location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. # try_files $uri $uri/ =404; proxy_pass http://127.0.0.1:8081; #填写frpc的vhost端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header REMOTE-HOST $remote_addr; } frp server端配置 vhost_http_port = 8081 frp client配置 [web1] type = http local_port = 80 custom_domains = yourdomain https 配置frp frp server vhost_https_port = 8082 frp client #plugin = https2http #plugin_local_addr = 127.0.0.1:1313 #本地服务器端口 # HTTPS证书的路径 #plugin_crt_path = /etc/frp/domain/yourdomain/fullchain1.pem #plugin_key_path = /etc/frp/domain/yourdomain/privkey1.pem #plugin_host_header_rewrite = 127.0.0.1 #plugin_header_X-From-Where = frp 或配置nginx map $ssl_preread_server_name $backend_name { default frp; } upstream frp { server 127.0.0.1:10013; } server { listen 10013 ssl; server_name *.duan-dky.me; ssl_certificate /etc/letsencrypt/live/duan-dky.me/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/duan-dky.me/privkey.pem; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. # try_files $uri $uri/ =404; proxy_pass http://127.0.0.1:8082; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_max_temp_file_size 0; proxy_redirect off; } } 5.frp注册成systemd服务 frp server端 [Unit] Description=FRP Server Daemon [Service] Type=simple ExecStartPre=-/usr/sbin/setcap cap_net_bind_service=+ep /usr/bin/frps ExecStart=/usr/bin/frps -c /etc/frp/frps.ini Restart=always RestartSec=2s User=nobody PermissionsStartOnly=true LimitNOFILE=infinity [Install] WantedBy=multi-user.target frp client端 [Unit] Description=FRP Client Daemon After=network.target Wants=network.target [Service] Type=simple ExecStart=/usr/bin/frpc -c /etc/frp/frpc.ini Restart=always RestartSec=20s User=nobody LimitNOFILE=infinity [Install] WantedBy=multi-user.target]]></summary></entry><entry><title type="html">rust学习</title><link href="http://localhost:4000/2022/07/27/rust-practice.html" rel="alternate" type="text/html" title="rust学习" /><published>2022-07-27T00:00:00+08:00</published><updated>2022-07-27T00:00:00+08:00</updated><id>http://localhost:4000/2022/07/27/rust-practice</id><content type="html" xml:base="http://localhost:4000/2022/07/27/rust-practice.html"><![CDATA[<p>1.rust函数</p>
<pre><code>fn main(){ //主函数
 println!(&quot;hello world!&quot;);
}
</code></pre>
<p>2.Rust变量
Rust 是强类型语言，但具有自动判断变量类型的能力。<br />
声明变量使用let关键字。<br />
重影:指变量的名称可以被重新使用。<br />
有符号类型</p>
<table>
<thead>
<tr>
<th>长度</th>
<th align="left">有符号</th>
<th align="center">无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8bit</td>
<td align="left">i8</td>
<td align="center">u8</td>
</tr>
<tr>
<td>16bit</td>
<td align="left">i16</td>
<td align="center">u16</td>
</tr>
<tr>
<td>32bit</td>
<td align="left">i32</td>
<td align="center">u32</td>
</tr>
<tr>
<td>64bit</td>
<td align="left">i64</td>
<td align="center">u64</td>
</tr>
<tr>
<td>128bit</td>
<td align="left">i128</td>
<td align="center">u128</td>
</tr>
<tr>
<td>arch</td>
<td align="left">isize</td>
<td align="center">usize</td>
</tr>
</tbody>
</table>]]></content><author><name>duan-dky</name><email>courage159357@gmail.com</email></author><category term="rust" /><summary type="html"><![CDATA[1.rust函数 fn main(){ //主函数 println!(&quot;hello world!&quot;); } 2.Rust变量 Rust 是强类型语言，但具有自动判断变量类型的能力。 声明变量使用let关键字。 重影:指变量的名称可以被重新使用。 有符号类型 长度 有符号 无符号 8bit i8 u8 16bit i16 u16 32bit i32 u32 64bit i64 u64 128bit i128 u128 arch isize usize]]></summary></entry><entry><title type="html">c++链表</title><link href="http://localhost:4000/2022/04/24/c++link.html" rel="alternate" type="text/html" title="c++链表" /><published>2022-04-24T00:00:00+08:00</published><updated>2022-04-24T00:00:00+08:00</updated><id>http://localhost:4000/2022/04/24/c++link</id><content type="html" xml:base="http://localhost:4000/2022/04/24/c++link.html"><![CDATA[<p>//查找元素</p>
<pre><code>std::pair&lt;int, int&gt; getElem(int a,list *l1)
{

    list *b=l1;
    int count=0;
    for(;b-&gt;next!=NULL;b=b-&gt;next){
        if(a==b-&gt;a){
            return std::pair&lt;int, int&gt;(a,count); //返回元素和下标
        }
        count++;
    }
    if(b-&gt;a==a){
        return std::pair&lt;int, int&gt;(a,count); //未找到返回-1
    }
    return std::pair&lt;int, int&gt;(a,-1);
    
}
</code></pre>]]></content><author><name>duan-dky</name><email>courage159357@gmail.com</email></author><category term="c++" /><summary type="html"><![CDATA[//查找元素 std::pair&lt;int, int&gt; getElem(int a,list *l1) { list *b=l1; int count=0; for(;b-&gt;next!=NULL;b=b-&gt;next){ if(a==b-&gt;a){ return std::pair&lt;int, int&gt;(a,count); //返回元素和下标 } count++; } if(b-&gt;a==a){ return std::pair&lt;int, int&gt;(a,count); //未找到返回-1 } return std::pair&lt;int, int&gt;(a,-1); }]]></summary></entry></feed>